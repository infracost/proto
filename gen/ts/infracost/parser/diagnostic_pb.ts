// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file infracost/parser/diagnostic.proto (package infracost.parser, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { SourceRange } from "./metadata_pb.js";

/**
 * @generated from enum infracost.parser.DiagnosticType
 */
export enum DiagnosticType {
  /**
   * @generated from enum value: DIAGNOSTIC_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * failed operation e.g. adding a string to an int, or error in operation func
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_FAILED_OPERATION = 1;
   */
  FAILED_OPERATION = 1,

  /**
   * bug in the parser code
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_DEFECT = 2;
   */
  DEFECT = 2,

  /**
   * could not parse the hcl, invalid code
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_HCL_PARSE_ERROR = 3;
   */
  HCL_PARSE_ERROR = 3,

  /**
   * missing function, i.e. not defined
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_MISSING_FUNC = 4;
   */
  MISSING_FUNC = 4,

  /**
   * failed to call function, cty function errored
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_FAILED_FUNCTION_CALL = 5;
   */
  FAILED_FUNCTION_CALL = 5,

  /**
   * e.g. string used for int
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_UNEXPECTED_TYPE = 6;
   */
  UNEXPECTED_TYPE = 6,

  /**
   * failed to download module
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_MODULE_FETCH_ERROR = 7;
   */
  MODULE_FETCH_ERROR = 7,

  /**
   * specifically a missing var input
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_MISSING_INPUT_VARIABLE = 8;
   */
  MISSING_INPUT_VARIABLE = 8,

  /**
   * @generated from enum value: DIAGNOSTIC_TYPE_MISSING_REFERENCE = 9;
   */
  MISSING_REFERENCE = 9,

  /**
   * e.g. cannot index into map
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_VALUE_INDEX_ERROR = 10;
   */
  VALUE_INDEX_ERROR = 10,

  /**
   * unknown expression type - possibly an expression we don't yet support
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_UNKNOWN_EXPRESSION = 11;
   */
  UNKNOWN_EXPRESSION = 11,

  /**
   * error trying to relatively traverse into a value e.g. function()[3]
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_RELATIVE_TRAVERSAL_ERROR = 12;
   */
  RELATIVE_TRAVERSAL_ERROR = 12,

  /**
   * invalid terraform configuration, e.g. dynamic block with no for_each
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_INVALID_TERRAFORM_CONFIGURATION = 13;
   */
  INVALID_TERRAFORM_CONFIGURATION = 13,

  /**
   * invalid terragrunt configuration, e.g. missing source
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_INVALID_TERRAGRUNT_CONFIGURATION = 14;
   */
  INVALID_TERRAGRUNT_CONFIGURATION = 14,

  /**
   * cyclic dependencies detected
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_TERRAFORM_CYCLIC_DEPENDENCY_DETECTED = 15;
   */
  TERRAFORM_CYCLIC_DEPENDENCY_DETECTED = 15,

  /**
   * terragrunt cyclic dependency detected
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_TERRAGRUNT_CYCLIC_DEPENDENCY_DETECTED = 16;
   */
  TERRAGRUNT_CYCLIC_DEPENDENCY_DETECTED = 16,

  /**
   * security error, e.g. trying to access a file outside of the repo directory
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_SECURITY_ERROR = 17;
   */
  SECURITY_ERROR = 17,

  /**
   * dependency error, e.g. missing module
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_DEPENDENCY_ERROR = 18;
   */
  DEPENDENCY_ERROR = 18,

  /**
   * filesystem error, e.g. missing file
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_FILESYSTEM_ERROR = 19;
   */
  FILESYSTEM_ERROR = 19,

  /**
   * invalid source map
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_INVALID_SOURCE_MAP = 20;
   */
  INVALID_SOURCE_MAP = 20,

  /**
   * no source files found
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_NO_SOURCE_FILES_FOUND = 21;
   */
  NO_SOURCE_FILES_FOUND = 21,

  /**
   * yor error
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_YOR_ERROR = 22;
   */
  YOR_ERROR = 22,

  /**
   * remote variable load error, e.g. TFC/Spacelift
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_REMOTE_VARIABLE_LOAD_ERROR = 23;
   */
  REMOTE_VARIABLE_LOAD_ERROR = 23,

  /**
   * cloudformation template error
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_INVALID_CLOUDFORMATION_TEMPLATE = 24;
   */
  INVALID_CLOUDFORMATION_TEMPLATE = 24,

  /**
   * cloudformation unsupported transform
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_UNSUPPORTED_CLOUDFORMATION_TRANSFORM = 25;
   */
  UNSUPPORTED_CLOUDFORMATION_TRANSFORM = 25,

  /**
   * cloudformation unsupported intrinsic function
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_UNSUPPORTED_CLOUDFORMATION_INTRINSIC_FUNCTION = 26;
   */
  UNSUPPORTED_CLOUDFORMATION_INTRINSIC_FUNCTION = 26,

  /**
   * cloudformation synthetic template url
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_SYNTHETIC_CLOUDFORMATION_TEMPLATE_URL = 27;
   */
  SYNTHETIC_CLOUDFORMATION_TEMPLATE_URL = 27,

  /**
   * cloudformation transform failed
   *
   * @generated from enum value: DIAGNOSTIC_TYPE_FAILED_CLOUDFORMATION_TRANSFORM = 28;
   */
  FAILED_CLOUDFORMATION_TRANSFORM = 28,
}
// Retrieve enum metadata with: proto3.getEnumType(DiagnosticType)
proto3.util.setEnumType(DiagnosticType, "infracost.parser.DiagnosticType", [
  { no: 0, name: "DIAGNOSTIC_TYPE_UNSPECIFIED" },
  { no: 1, name: "DIAGNOSTIC_TYPE_FAILED_OPERATION" },
  { no: 2, name: "DIAGNOSTIC_TYPE_DEFECT" },
  { no: 3, name: "DIAGNOSTIC_TYPE_HCL_PARSE_ERROR" },
  { no: 4, name: "DIAGNOSTIC_TYPE_MISSING_FUNC" },
  { no: 5, name: "DIAGNOSTIC_TYPE_FAILED_FUNCTION_CALL" },
  { no: 6, name: "DIAGNOSTIC_TYPE_UNEXPECTED_TYPE" },
  { no: 7, name: "DIAGNOSTIC_TYPE_MODULE_FETCH_ERROR" },
  { no: 8, name: "DIAGNOSTIC_TYPE_MISSING_INPUT_VARIABLE" },
  { no: 9, name: "DIAGNOSTIC_TYPE_MISSING_REFERENCE" },
  { no: 10, name: "DIAGNOSTIC_TYPE_VALUE_INDEX_ERROR" },
  { no: 11, name: "DIAGNOSTIC_TYPE_UNKNOWN_EXPRESSION" },
  { no: 12, name: "DIAGNOSTIC_TYPE_RELATIVE_TRAVERSAL_ERROR" },
  { no: 13, name: "DIAGNOSTIC_TYPE_INVALID_TERRAFORM_CONFIGURATION" },
  { no: 14, name: "DIAGNOSTIC_TYPE_INVALID_TERRAGRUNT_CONFIGURATION" },
  { no: 15, name: "DIAGNOSTIC_TYPE_TERRAFORM_CYCLIC_DEPENDENCY_DETECTED" },
  { no: 16, name: "DIAGNOSTIC_TYPE_TERRAGRUNT_CYCLIC_DEPENDENCY_DETECTED" },
  { no: 17, name: "DIAGNOSTIC_TYPE_SECURITY_ERROR" },
  { no: 18, name: "DIAGNOSTIC_TYPE_DEPENDENCY_ERROR" },
  { no: 19, name: "DIAGNOSTIC_TYPE_FILESYSTEM_ERROR" },
  { no: 20, name: "DIAGNOSTIC_TYPE_INVALID_SOURCE_MAP" },
  { no: 21, name: "DIAGNOSTIC_TYPE_NO_SOURCE_FILES_FOUND" },
  { no: 22, name: "DIAGNOSTIC_TYPE_YOR_ERROR" },
  { no: 23, name: "DIAGNOSTIC_TYPE_REMOTE_VARIABLE_LOAD_ERROR" },
  { no: 24, name: "DIAGNOSTIC_TYPE_INVALID_CLOUDFORMATION_TEMPLATE" },
  { no: 25, name: "DIAGNOSTIC_TYPE_UNSUPPORTED_CLOUDFORMATION_TRANSFORM" },
  { no: 26, name: "DIAGNOSTIC_TYPE_UNSUPPORTED_CLOUDFORMATION_INTRINSIC_FUNCTION" },
  { no: 27, name: "DIAGNOSTIC_TYPE_SYNTHETIC_CLOUDFORMATION_TEMPLATE_URL" },
  { no: 28, name: "DIAGNOSTIC_TYPE_FAILED_CLOUDFORMATION_TRANSFORM" },
]);

/**
 * Diagnostic is information about something that went wrong during
 * parsing, for any reason.
 * A Diagnostic is considered Critical if it is something the user needs
 * to be alerted about, e.g. a module download failing due to invalid
 * credentials.
 *
 * @generated from message infracost.parser.Diagnostic
 */
export class Diagnostic extends Message<Diagnostic> {
  /**
   * @generated from field: string error = 1;
   */
  error = "";

  /**
   * @generated from field: map<string, string> labels = 2;
   */
  labels: { [key: string]: string } = {};

  /**
   * @generated from field: infracost.parser.SourceRange source_range = 3;
   */
  sourceRange?: SourceRange;

  /**
   * @generated from field: infracost.parser.DiagnosticType type = 4;
   */
  type = DiagnosticType.UNSPECIFIED;

  /**
   * @generated from field: bool critical = 5;
   */
  critical = false;

  /**
   * @generated from field: bool warning = 6;
   */
  warning = false;

  /**
   * @generated from field: bool ignored = 7;
   */
  ignored = false;

  constructor(data?: PartialMessage<Diagnostic>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.Diagnostic";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 3, name: "source_range", kind: "message", T: SourceRange },
    { no: 4, name: "type", kind: "enum", T: proto3.getEnumType(DiagnosticType) },
    { no: 5, name: "critical", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "warning", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "ignored", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Diagnostic {
    return new Diagnostic().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Diagnostic {
    return new Diagnostic().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Diagnostic {
    return new Diagnostic().fromJsonString(jsonString, options);
  }

  static equals(a: Diagnostic | PlainMessage<Diagnostic> | undefined, b: Diagnostic | PlainMessage<Diagnostic> | undefined): boolean {
    return proto3.util.equals(Diagnostic, a, b);
  }
}

