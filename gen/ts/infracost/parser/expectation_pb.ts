// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file infracost/parser/expectation.proto (package infracost.parser, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from enum infracost.parser.ExpectationType
 */
export enum ExpectationType {
  /**
   * @generated from enum value: EXPECTATION_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: EXPECTATION_TYPE_ANY = 1;
   */
  ANY = 1,

  /**
   * @generated from enum value: EXPECTATION_TYPE_STRING = 2;
   */
  STRING = 2,

  /**
   * @generated from enum value: EXPECTATION_TYPE_NUMBER = 3;
   */
  NUMBER = 3,

  /**
   * @generated from enum value: EXPECTATION_TYPE_BOOL = 4;
   */
  BOOL = 4,

  /**
   * @generated from enum value: EXPECTATION_TYPE_MAP = 5;
   */
  MAP = 5,

  /**
   * @generated from enum value: EXPECTATION_TYPE_OBJECT = 6;
   */
  OBJECT = 6,

  /**
   * @generated from enum value: EXPECTATION_TYPE_LIST = 7;
   */
  LIST = 7,

  /**
   * @generated from enum value: EXPECTATION_TYPE_TUPLE = 8;
   */
  TUPLE = 8,

  /**
   * @generated from enum value: EXPECTATION_TYPE_SET = 9;
   */
  SET = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(ExpectationType)
proto3.util.setEnumType(ExpectationType, "infracost.parser.ExpectationType", [
  { no: 0, name: "EXPECTATION_TYPE_UNSPECIFIED" },
  { no: 1, name: "EXPECTATION_TYPE_ANY" },
  { no: 2, name: "EXPECTATION_TYPE_STRING" },
  { no: 3, name: "EXPECTATION_TYPE_NUMBER" },
  { no: 4, name: "EXPECTATION_TYPE_BOOL" },
  { no: 5, name: "EXPECTATION_TYPE_MAP" },
  { no: 6, name: "EXPECTATION_TYPE_OBJECT" },
  { no: 7, name: "EXPECTATION_TYPE_LIST" },
  { no: 8, name: "EXPECTATION_TYPE_TUPLE" },
  { no: 9, name: "EXPECTATION_TYPE_SET" },
]);

/**
 * @generated from message infracost.parser.Expectation
 */
export class Expectation extends Message<Expectation> {
  /**
   * @generated from field: infracost.parser.ExpectationType type = 1;
   */
  type = ExpectationType.UNSPECIFIED;

  /**
   * @generated from oneof infracost.parser.Expectation.type_data
   */
  typeData: {
    /**
     * @generated from field: infracost.parser.Primitive primitive = 2;
     */
    value: Primitive;
    case: "primitive";
  } | {
    /**
     * @generated from field: infracost.parser.Map map = 3;
     */
    value: Map;
    case: "map";
  } | {
    /**
     * @generated from field: infracost.parser.Object object = 4;
     */
    value: Object$;
    case: "object";
  } | {
    /**
     * @generated from field: infracost.parser.List list = 5;
     */
    value: List;
    case: "list";
  } | {
    /**
     * @generated from field: infracost.parser.Tuple tuple = 6;
     */
    value: Tuple;
    case: "tuple";
  } | {
    /**
     * @generated from field: infracost.parser.Set set = 7;
     */
    value: Set;
    case: "set";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Expectation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.Expectation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(ExpectationType) },
    { no: 2, name: "primitive", kind: "message", T: Primitive, oneof: "type_data" },
    { no: 3, name: "map", kind: "message", T: Map, oneof: "type_data" },
    { no: 4, name: "object", kind: "message", T: Object$, oneof: "type_data" },
    { no: 5, name: "list", kind: "message", T: List, oneof: "type_data" },
    { no: 6, name: "tuple", kind: "message", T: Tuple, oneof: "type_data" },
    { no: 7, name: "set", kind: "message", T: Set, oneof: "type_data" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Expectation {
    return new Expectation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Expectation {
    return new Expectation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Expectation {
    return new Expectation().fromJsonString(jsonString, options);
  }

  static equals(a: Expectation | PlainMessage<Expectation> | undefined, b: Expectation | PlainMessage<Expectation> | undefined): boolean {
    return proto3.util.equals(Expectation, a, b);
  }
}

/**
 * @generated from message infracost.parser.Primitive
 */
export class Primitive extends Message<Primitive> {
  /**
   * @generated from field: bool is_non_zero = 1;
   */
  isNonZero = false;

  constructor(data?: PartialMessage<Primitive>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.Primitive";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_non_zero", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Primitive {
    return new Primitive().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Primitive {
    return new Primitive().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Primitive {
    return new Primitive().fromJsonString(jsonString, options);
  }

  static equals(a: Primitive | PlainMessage<Primitive> | undefined, b: Primitive | PlainMessage<Primitive> | undefined): boolean {
    return proto3.util.equals(Primitive, a, b);
  }
}

/**
 * @generated from message infracost.parser.Map
 */
export class Map extends Message<Map> {
  /**
   * @generated from field: infracost.parser.Expectation element_type = 1;
   */
  elementType?: Expectation;

  constructor(data?: PartialMessage<Map>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.Map";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "element_type", kind: "message", T: Expectation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Map {
    return new Map().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Map {
    return new Map().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Map {
    return new Map().fromJsonString(jsonString, options);
  }

  static equals(a: Map | PlainMessage<Map> | undefined, b: Map | PlainMessage<Map> | undefined): boolean {
    return proto3.util.equals(Map, a, b);
  }
}

/**
 * @generated from message infracost.parser.Object
 */
export class Object$ extends Message<Object$> {
  /**
   * @generated from field: map<string, infracost.parser.Expectation> types = 1;
   */
  types: { [key: string]: Expectation } = {};

  constructor(data?: PartialMessage<Object$>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.Object";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "types", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Expectation} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Object$ {
    return new Object$().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Object$ {
    return new Object$().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Object$ {
    return new Object$().fromJsonString(jsonString, options);
  }

  static equals(a: Object$ | PlainMessage<Object$> | undefined, b: Object$ | PlainMessage<Object$> | undefined): boolean {
    return proto3.util.equals(Object$, a, b);
  }
}

/**
 * @generated from message infracost.parser.List
 */
export class List extends Message<List> {
  /**
   * @generated from field: infracost.parser.Expectation element_type = 1;
   */
  elementType?: Expectation;

  constructor(data?: PartialMessage<List>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.List";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "element_type", kind: "message", T: Expectation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): List {
    return new List().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): List {
    return new List().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): List {
    return new List().fromJsonString(jsonString, options);
  }

  static equals(a: List | PlainMessage<List> | undefined, b: List | PlainMessage<List> | undefined): boolean {
    return proto3.util.equals(List, a, b);
  }
}

/**
 * @generated from message infracost.parser.Tuple
 */
export class Tuple extends Message<Tuple> {
  /**
   * @generated from field: repeated infracost.parser.Expectation element_types = 1;
   */
  elementTypes: Expectation[] = [];

  constructor(data?: PartialMessage<Tuple>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.Tuple";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "element_types", kind: "message", T: Expectation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Tuple {
    return new Tuple().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Tuple {
    return new Tuple().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Tuple {
    return new Tuple().fromJsonString(jsonString, options);
  }

  static equals(a: Tuple | PlainMessage<Tuple> | undefined, b: Tuple | PlainMessage<Tuple> | undefined): boolean {
    return proto3.util.equals(Tuple, a, b);
  }
}

/**
 * @generated from message infracost.parser.Set
 */
export class Set extends Message<Set> {
  /**
   * @generated from field: infracost.parser.Expectation element_type = 1;
   */
  elementType?: Expectation;

  constructor(data?: PartialMessage<Set>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.Set";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "element_type", kind: "message", T: Expectation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Set {
    return new Set().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Set {
    return new Set().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Set {
    return new Set().fromJsonString(jsonString, options);
  }

  static equals(a: Set | PlainMessage<Set> | undefined, b: Set | PlainMessage<Set> | undefined): boolean {
    return proto3.util.equals(Set, a, b);
  }
}

