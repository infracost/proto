// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file infracost/parser/event/event.proto (package infracost.parser.event, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { RunParameters } from "./runparameters_pb.js";

/**
 * @generated from message infracost.parser.event.Event
 */
export class Event extends Message<Event> {
  /**
   * @generated from field: infracost.parser.event.Event.Type type = 1;
   */
  type = Event_Type.UNSPECIFIED;

  /**
   * @generated from field: infracost.parser.event.Metadata metadata = 2;
   */
  metadata?: Metadata;

  /**
   * @generated from field: infracost.parser.event.Environment environment = 3;
   */
  environment?: Environment;

  /**
   * @generated from field: infracost.parser.event.AWSConfig aws_config = 4;
   */
  awsConfig?: AWSConfig;

  /**
   * @generated from field: infracost.parser.event.VCS vcs = 5;
   */
  vcs?: VCS;

  /**
   * @generated from field: infracost.parser.event.JobBehavior job_behavior = 6;
   */
  jobBehavior?: JobBehavior;

  /**
   * @generated from field: infracost.parser.event.JobConfiguration job_configuration = 7;
   */
  jobConfiguration?: JobConfiguration;

  /**
   * @generated from field: infracost.parser.event.InfracostServices services = 8;
   */
  services?: InfracostServices;

  /**
   * @generated from field: infracost.parser.event.Telemetry telemetry = 9;
   */
  telemetry?: Telemetry;

  /**
   * @generated from field: infracost.parser.event.DecryptionKey decryption_key = 10;
   */
  decryptionKey?: DecryptionKey;

  /**
   * @generated from field: infracost.parser.event.RunParameters run_parameters = 11;
   */
  runParameters?: RunParameters;

  constructor(data?: PartialMessage<Event>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.Event";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(Event_Type) },
    { no: 2, name: "metadata", kind: "message", T: Metadata },
    { no: 3, name: "environment", kind: "message", T: Environment },
    { no: 4, name: "aws_config", kind: "message", T: AWSConfig },
    { no: 5, name: "vcs", kind: "message", T: VCS },
    { no: 6, name: "job_behavior", kind: "message", T: JobBehavior },
    { no: 7, name: "job_configuration", kind: "message", T: JobConfiguration },
    { no: 8, name: "services", kind: "message", T: InfracostServices },
    { no: 9, name: "telemetry", kind: "message", T: Telemetry },
    { no: 10, name: "decryption_key", kind: "message", T: DecryptionKey },
    { no: 11, name: "run_parameters", kind: "message", T: RunParameters },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Event {
    return new Event().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Event {
    return new Event().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Event {
    return new Event().fromJsonString(jsonString, options);
  }

  static equals(a: Event | PlainMessage<Event> | undefined, b: Event | PlainMessage<Event> | undefined): boolean {
    return proto3.util.equals(Event, a, b);
  }
}

/**
 * @generated from enum infracost.parser.event.Event.Type
 */
export enum Event_Type {
  /**
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * pr
   *
   * @generated from enum value: PULL_REQUEST_OPENED = 1;
   */
  PULL_REQUEST_OPENED = 1,

  /**
   * @generated from enum value: PULL_REQUEST_CHANGED = 2;
   */
  PULL_REQUEST_CHANGED = 2,

  /**
   * @generated from enum value: PULL_REQUEST_EDITED = 3;
   */
  PULL_REQUEST_EDITED = 3,

  /**
   * branch
   *
   * @generated from enum value: BRANCH_BASE_CHANGED = 4;
   */
  BRANCH_BASE_CHANGED = 4,

  /**
   * @generated from enum value: BRANCH_DEFAULT_CHANGED = 5;
   */
  BRANCH_DEFAULT_CHANGED = 5,

  /**
   * @generated from enum value: REPO_INIT = 6;
   */
  REPO_INIT = 6,

  /**
   * @generated from enum value: REPO_REFETCH_BASE_BRANCH = 7;
   */
  REPO_REFETCH_BASE_BRANCH = 7,

  /**
   * debug
   *
   * @generated from enum value: DEV_INFRACOST_CLONE = 8;
   */
  DEV_INFRACOST_CLONE = 8,

  /**
   * reevaluate
   *
   * @generated from enum value: REPO_REEVALUATE_BASE_BRANCH = 9;
   */
  REPO_REEVALUATE_BASE_BRANCH = 9,

  /**
   * ai
   *
   * @generated from enum value: FIX_ISSUE = 10;
   */
  FIX_ISSUE = 10,
}
// Retrieve enum metadata with: proto3.getEnumType(Event_Type)
proto3.util.setEnumType(Event_Type, "infracost.parser.event.Event.Type", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "PULL_REQUEST_OPENED" },
  { no: 2, name: "PULL_REQUEST_CHANGED" },
  { no: 3, name: "PULL_REQUEST_EDITED" },
  { no: 4, name: "BRANCH_BASE_CHANGED" },
  { no: 5, name: "BRANCH_DEFAULT_CHANGED" },
  { no: 6, name: "REPO_INIT" },
  { no: 7, name: "REPO_REFETCH_BASE_BRANCH" },
  { no: 8, name: "DEV_INFRACOST_CLONE" },
  { no: 9, name: "REPO_REEVALUATE_BASE_BRANCH" },
  { no: 10, name: "FIX_ISSUE" },
]);

/**
 * @generated from message infracost.parser.event.Environment
 */
export class Environment extends Message<Environment> {
  /**
   * @generated from field: infracost.parser.event.Environment.Type type = 1;
   */
  type = Environment_Type.DEV;

  /**
   * @generated from field: bool ci = 2;
   */
  ci = false;

  constructor(data?: PartialMessage<Environment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.Environment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(Environment_Type) },
    { no: 2, name: "ci", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Environment {
    return new Environment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Environment {
    return new Environment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Environment {
    return new Environment().fromJsonString(jsonString, options);
  }

  static equals(a: Environment | PlainMessage<Environment> | undefined, b: Environment | PlainMessage<Environment> | undefined): boolean {
    return proto3.util.equals(Environment, a, b);
  }
}

/**
 * @generated from enum infracost.parser.event.Environment.Type
 */
export enum Environment_Type {
  /**
   * @generated from enum value: DEV = 0;
   */
  DEV = 0,

  /**
   * @generated from enum value: PROD = 1;
   */
  PROD = 1,

  /**
   * @generated from enum value: LOCAL = 2;
   */
  LOCAL = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Environment_Type)
proto3.util.setEnumType(Environment_Type, "infracost.parser.event.Environment.Type", [
  { no: 0, name: "DEV" },
  { no: 1, name: "PROD" },
  { no: 2, name: "LOCAL" },
]);

/**
 * @generated from message infracost.parser.event.DecryptionKey
 */
export class DecryptionKey extends Message<DecryptionKey> {
  /**
   * @generated from field: string encrypted_dek = 1;
   */
  encryptedDek = "";

  constructor(data?: PartialMessage<DecryptionKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.DecryptionKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encrypted_dek", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DecryptionKey {
    return new DecryptionKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DecryptionKey {
    return new DecryptionKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DecryptionKey {
    return new DecryptionKey().fromJsonString(jsonString, options);
  }

  static equals(a: DecryptionKey | PlainMessage<DecryptionKey> | undefined, b: DecryptionKey | PlainMessage<DecryptionKey> | undefined): boolean {
    return proto3.util.equals(DecryptionKey, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.Secret
 */
export class Secret extends Message<Secret> {
  /**
   * @generated from field: string encrypted = 1;
   */
  encrypted = "";

  constructor(data?: PartialMessage<Secret>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.Secret";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encrypted", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Secret {
    return new Secret().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Secret {
    return new Secret().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Secret {
    return new Secret().fromJsonString(jsonString, options);
  }

  static equals(a: Secret | PlainMessage<Secret> | undefined, b: Secret | PlainMessage<Secret> | undefined): boolean {
    return proto3.util.equals(Secret, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.VCS
 */
export class VCS extends Message<VCS> {
  /**
   * @generated from field: infracost.parser.event.VCS.Type type = 1;
   */
  type = VCS_Type.UNSPECIFIED;

  /**
   * @generated from field: string source_raw_event = 2;
   */
  sourceRawEvent = "";

  /**
   * @generated from field: infracost.parser.event.GitHubApplication github_application = 3;
   */
  githubApplication?: GitHubApplication;

  /**
   * @generated from field: infracost.parser.event.AzureRepos azure_repos = 4;
   */
  azureRepos?: AzureRepos;

  /**
   * @generated from field: string pullrequest_check_id = 5;
   */
  pullrequestCheckId = "";

  /**
   * @generated from field: bool reuse_cloned_repos = 6;
   */
  reuseClonedRepos = false;

  /**
   * @generated from field: string clone_base_dir = 7;
   */
  cloneBaseDir = "";

  constructor(data?: PartialMessage<VCS>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.VCS";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(VCS_Type) },
    { no: 2, name: "source_raw_event", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "github_application", kind: "message", T: GitHubApplication },
    { no: 4, name: "azure_repos", kind: "message", T: AzureRepos },
    { no: 5, name: "pullrequest_check_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "reuse_cloned_repos", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "clone_base_dir", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VCS {
    return new VCS().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VCS {
    return new VCS().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VCS {
    return new VCS().fromJsonString(jsonString, options);
  }

  static equals(a: VCS | PlainMessage<VCS> | undefined, b: VCS | PlainMessage<VCS> | undefined): boolean {
    return proto3.util.equals(VCS, a, b);
  }
}

/**
 * @generated from enum infracost.parser.event.VCS.Type
 */
export enum VCS_Type {
  /**
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: GITLAB = 1;
   */
  GITLAB = 1,

  /**
   * @generated from enum value: GITHUB = 2;
   */
  GITHUB = 2,

  /**
   * @generated from enum value: AZURE_REPOS = 3;
   */
  AZURE_REPOS = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(VCS_Type)
proto3.util.setEnumType(VCS_Type, "infracost.parser.event.VCS.Type", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "GITLAB" },
  { no: 2, name: "GITHUB" },
  { no: 3, name: "AZURE_REPOS" },
]);

/**
 * @generated from message infracost.parser.event.Metadata
 */
export class Metadata extends Message<Metadata> {
  /**
   * @generated from field: google.protobuf.Timestamp timestamp_received = 1;
   */
  timestampReceived?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp timestamp_created = 2;
   */
  timestampCreated?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp timestamp_queued = 3;
   */
  timestampQueued?: Timestamp;

  /**
   * @generated from field: string replay_id = 4;
   */
  replayId = "";

  /**
   * @generated from field: string pipeline_id = 5;
   */
  pipelineId = "";

  /**
   * @generated from field: string delivery_id = 6;
   */
  deliveryId = "";

  /**
   * @generated from field: bool is_last_try = 7;
   */
  isLastTry = false;

  constructor(data?: PartialMessage<Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp_received", kind: "message", T: Timestamp },
    { no: 2, name: "timestamp_created", kind: "message", T: Timestamp },
    { no: 3, name: "timestamp_queued", kind: "message", T: Timestamp },
    { no: 4, name: "replay_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "pipeline_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "delivery_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "is_last_try", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metadata {
    return new Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: Metadata | PlainMessage<Metadata> | undefined, b: Metadata | PlainMessage<Metadata> | undefined): boolean {
    return proto3.util.equals(Metadata, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.AWSConfig
 */
export class AWSConfig extends Message<AWSConfig> {
  /**
   * @generated from field: string region = 1;
   */
  region = "";

  /**
   * @generated from field: string endpoint = 2;
   */
  endpoint = "";

  constructor(data?: PartialMessage<AWSConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.AWSConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AWSConfig {
    return new AWSConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AWSConfig {
    return new AWSConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AWSConfig {
    return new AWSConfig().fromJsonString(jsonString, options);
  }

  static equals(a: AWSConfig | PlainMessage<AWSConfig> | undefined, b: AWSConfig | PlainMessage<AWSConfig> | undefined): boolean {
    return proto3.util.equals(AWSConfig, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.Cache
 */
export class Cache extends Message<Cache> {
  /**
   * @generated from field: bool disabled = 1;
   */
  disabled = false;

  /**
   * @generated from field: string s3_module_cache_region = 2;
   */
  s3ModuleCacheRegion = "";

  /**
   * @generated from field: string s3_module_cache_bucket = 3;
   */
  s3ModuleCacheBucket = "";

  /**
   * @generated from field: string s3_module_cache_prefix = 4;
   */
  s3ModuleCachePrefix = "";

  /**
   * @generated from field: bool s3_module_cache_private = 5;
   */
  s3ModuleCachePrivate = false;

  constructor(data?: PartialMessage<Cache>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.Cache";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "disabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "s3_module_cache_region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "s3_module_cache_bucket", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "s3_module_cache_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "s3_module_cache_private", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Cache {
    return new Cache().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Cache {
    return new Cache().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Cache {
    return new Cache().fromJsonString(jsonString, options);
  }

  static equals(a: Cache | PlainMessage<Cache> | undefined, b: Cache | PlainMessage<Cache> | undefined): boolean {
    return proto3.util.equals(Cache, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.GitHubApplication
 */
export class GitHubApplication extends Message<GitHubApplication> {
  /**
   * @generated from field: infracost.parser.event.Secret access_token = 1;
   */
  accessToken?: Secret;

  /**
   * @generated from field: string base_url = 2;
   */
  baseUrl = "";

  /**
   * @generated from field: int64 app_id = 3;
   */
  appId = protoInt64.zero;

  constructor(data?: PartialMessage<GitHubApplication>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.GitHubApplication";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "access_token", kind: "message", T: Secret },
    { no: 2, name: "base_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "app_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GitHubApplication {
    return new GitHubApplication().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GitHubApplication {
    return new GitHubApplication().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GitHubApplication {
    return new GitHubApplication().fromJsonString(jsonString, options);
  }

  static equals(a: GitHubApplication | PlainMessage<GitHubApplication> | undefined, b: GitHubApplication | PlainMessage<GitHubApplication> | undefined): boolean {
    return proto3.util.equals(GitHubApplication, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.AzureRepos
 */
export class AzureRepos extends Message<AzureRepos> {
  /**
   * @generated from field: infracost.parser.event.Secret access_token = 1;
   */
  accessToken?: Secret;

  /**
   * @generated from field: string base_url = 2;
   */
  baseUrl = "";

  constructor(data?: PartialMessage<AzureRepos>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.AzureRepos";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "access_token", kind: "message", T: Secret },
    { no: 2, name: "base_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AzureRepos {
    return new AzureRepos().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AzureRepos {
    return new AzureRepos().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AzureRepos {
    return new AzureRepos().fromJsonString(jsonString, options);
  }

  static equals(a: AzureRepos | PlainMessage<AzureRepos> | undefined, b: AzureRepos | PlainMessage<AzureRepos> | undefined): boolean {
    return proto3.util.equals(AzureRepos, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.FeatureFlags
 */
export class FeatureFlags extends Message<FeatureFlags> {
  /**
   * @generated from field: bool enable_cloud_formation = 1;
   */
  enableCloudFormation = false;

  /**
   * @generated from field: bool enable_cloud_formation_cdk = 2;
   */
  enableCloudFormationCdk = false;

  constructor(data?: PartialMessage<FeatureFlags>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.FeatureFlags";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enable_cloud_formation", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "enable_cloud_formation_cdk", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeatureFlags {
    return new FeatureFlags().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeatureFlags {
    return new FeatureFlags().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeatureFlags {
    return new FeatureFlags().fromJsonString(jsonString, options);
  }

  static equals(a: FeatureFlags | PlainMessage<FeatureFlags> | undefined, b: FeatureFlags | PlainMessage<FeatureFlags> | undefined): boolean {
    return proto3.util.equals(FeatureFlags, a, b);
  }
}

/**
 * What gets executed
 *
 * @generated from message infracost.parser.event.JobBehavior
 */
export class JobBehavior extends Message<JobBehavior> {
  /**
   * @generated from field: bool no_comment = 1;
   */
  noComment = false;

  /**
   * @generated from field: bool usage_api_enabled = 2;
   */
  usageApiEnabled = false;

  /**
   * @generated from field: string build_script = 3;
   */
  buildScript = "";

  /**
   * @generated from field: string custom_property_mapping_script = 4;
   */
  customPropertyMappingScript = "";

  /**
   * @generated from field: infracost.parser.event.FeatureFlags feature_flags = 5;
   */
  featureFlags?: FeatureFlags;

  constructor(data?: PartialMessage<JobBehavior>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.JobBehavior";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "no_comment", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "usage_api_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "build_script", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "custom_property_mapping_script", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "feature_flags", kind: "message", T: FeatureFlags },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobBehavior {
    return new JobBehavior().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobBehavior {
    return new JobBehavior().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobBehavior {
    return new JobBehavior().fromJsonString(jsonString, options);
  }

  static equals(a: JobBehavior | PlainMessage<JobBehavior> | undefined, b: JobBehavior | PlainMessage<JobBehavior> | undefined): boolean {
    return proto3.util.equals(JobBehavior, a, b);
  }
}

/**
 * How it gets executed
 *
 * @generated from message infracost.parser.event.JobConfiguration
 */
export class JobConfiguration extends Message<JobConfiguration> {
  /**
   * @generated from field: string log_level = 1;
   */
  logLevel = "";

  /**
   * @generated from field: string prompt_path = 2;
   */
  promptPath = "";

  /**
   * @generated from field: string infracost_binary = 3;
   */
  infracostBinary = "";

  /**
   * @generated from field: string runner_provider = 4;
   */
  runnerProvider = "";

  /**
   * @generated from field: string go_max_procs = 5;
   */
  goMaxProcs = "";

  /**
   * @generated from field: int32 max_vcs_redirects = 6;
   */
  maxVcsRedirects = 0;

  /**
   * @generated from field: int32 infracost_parallelism = 7;
   */
  infracostParallelism = 0;

  /**
   * @generated from field: google.protobuf.Duration max_wait_vcs_api = 8;
   */
  maxWaitVcsApi?: Duration;

  /**
   * @generated from field: bool interactive_shell = 9;
   */
  interactiveShell = false;

  /**
   * @generated from field: bool debug_run = 10;
   */
  debugRun = false;

  /**
   * @generated from field: bool sparse_checkout = 11;
   */
  sparseCheckout = false;

  /**
   * @generated from field: bool use_s3_results_ingestion = 12;
   */
  useS3ResultsIngestion = false;

  /**
   * @generated from field: bool wait_for_metrics_during_shutdown = 13;
   */
  waitForMetricsDuringShutdown = false;

  /**
   * @generated from field: infracost.parser.event.Cache cache = 14;
   */
  cache?: Cache;

  constructor(data?: PartialMessage<JobConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.JobConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "log_level", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "prompt_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "infracost_binary", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "runner_provider", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "go_max_procs", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "max_vcs_redirects", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "infracost_parallelism", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "max_wait_vcs_api", kind: "message", T: Duration },
    { no: 9, name: "interactive_shell", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "debug_run", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "sparse_checkout", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "use_s3_results_ingestion", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "wait_for_metrics_during_shutdown", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "cache", kind: "message", T: Cache },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobConfiguration {
    return new JobConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobConfiguration {
    return new JobConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobConfiguration {
    return new JobConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: JobConfiguration | PlainMessage<JobConfiguration> | undefined, b: JobConfiguration | PlainMessage<JobConfiguration> | undefined): boolean {
    return proto3.util.equals(JobConfiguration, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.InfracostServices
 */
export class InfracostServices extends Message<InfracostServices> {
  /**
   * @generated from field: infracost.parser.event.Secret auth_token = 1;
   */
  authToken?: Secret;

  /**
   * @generated from field: string registry_proxy = 2;
   */
  registryProxy = "";

  /**
   * @generated from field: string web_url = 3;
   */
  webUrl = "";

  /**
   * @generated from field: string pricing_api_endpoint = 4;
   */
  pricingApiEndpoint = "";

  /**
   * @generated from field: string recommendation_api_endpoint = 5;
   */
  recommendationApiEndpoint = "";

  /**
   * @generated from field: string dashboard_api_endpoint = 6;
   */
  dashboardApiEndpoint = "";

  /**
   * @generated from field: string auth0_claims_namespace = 7;
   */
  auth0ClaimsNamespace = "";

  /**
   * @generated from field: google.protobuf.Duration api_client_timeout = 8;
   */
  apiClientTimeout?: Duration;

  /**
   * @generated from field: bool use_graph_evaluator = 9;
   */
  useGraphEvaluator = false;

  constructor(data?: PartialMessage<InfracostServices>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.InfracostServices";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "auth_token", kind: "message", T: Secret },
    { no: 2, name: "registry_proxy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "web_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "pricing_api_endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "recommendation_api_endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "dashboard_api_endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "auth0_claims_namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "api_client_timeout", kind: "message", T: Duration },
    { no: 9, name: "use_graph_evaluator", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InfracostServices {
    return new InfracostServices().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InfracostServices {
    return new InfracostServices().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InfracostServices {
    return new InfracostServices().fromJsonString(jsonString, options);
  }

  static equals(a: InfracostServices | PlainMessage<InfracostServices> | undefined, b: InfracostServices | PlainMessage<InfracostServices> | undefined): boolean {
    return proto3.util.equals(InfracostServices, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.Telemetry
 */
export class Telemetry extends Message<Telemetry> {
  /**
   * @generated from field: string sentry_dsn = 1;
   */
  sentryDsn = "";

  /**
   * @generated from field: string metrics_addr = 2;
   */
  metricsAddr = "";

  /**
   * @generated from field: bool disable_observability = 3;
   */
  disableObservability = false;

  /**
   * @generated from field: bool enable_environmental_metrics = 4;
   */
  enableEnvironmentalMetrics = false;

  /**
   * @generated from field: infracost.parser.event.Langfuse langfuse = 5;
   */
  langfuse?: Langfuse;

  constructor(data?: PartialMessage<Telemetry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.Telemetry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sentry_dsn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metrics_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "disable_observability", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "enable_environmental_metrics", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "langfuse", kind: "message", T: Langfuse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Telemetry {
    return new Telemetry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Telemetry {
    return new Telemetry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Telemetry {
    return new Telemetry().fromJsonString(jsonString, options);
  }

  static equals(a: Telemetry | PlainMessage<Telemetry> | undefined, b: Telemetry | PlainMessage<Telemetry> | undefined): boolean {
    return proto3.util.equals(Telemetry, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.Langfuse
 */
export class Langfuse extends Message<Langfuse> {
  /**
   * @generated from field: string base_url = 1;
   */
  baseUrl = "";

  /**
   * @generated from field: string public_key = 2;
   */
  publicKey = "";

  /**
   * @generated from field: infracost.parser.event.Secret private_key = 3;
   */
  privateKey?: Secret;

  constructor(data?: PartialMessage<Langfuse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.Langfuse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "base_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "public_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "private_key", kind: "message", T: Secret },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Langfuse {
    return new Langfuse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Langfuse {
    return new Langfuse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Langfuse {
    return new Langfuse().fromJsonString(jsonString, options);
  }

  static equals(a: Langfuse | PlainMessage<Langfuse> | undefined, b: Langfuse | PlainMessage<Langfuse> | undefined): boolean {
    return proto3.util.equals(Langfuse, a, b);
  }
}

