// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file infracost/parser/event/runparameters.proto (package infracost.parser.event, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message infracost.parser.event.RunParameters
 */
export class RunParameters extends Message<RunParameters> {
  /**
   * @generated from field: infracost.parser.event.BaseScope scope = 1;
   */
  scope?: BaseScope;

  /**
   * @generated from field: infracost.parser.event.UsageDefaults usage_defaults = 2;
   */
  usageDefaults?: UsageDefaults;

  /**
   * @generated from field: repeated infracost.parser.event.ProductionFilter production_filters = 3;
   */
  productionFilters: ProductionFilter[] = [];

  /**
   * @generated from field: repeated infracost.parser.event.TagPolicy tag_policies = 4;
   */
  tagPolicies: TagPolicy[] = [];

  /**
   * @generated from field: repeated infracost.parser.event.FinopsPolicySettings finops_policies = 5;
   */
  finopsPolicies: FinopsPolicySettings[] = [];

  constructor(data?: PartialMessage<RunParameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.RunParameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "scope", kind: "message", T: BaseScope },
    { no: 2, name: "usage_defaults", kind: "message", T: UsageDefaults },
    { no: 3, name: "production_filters", kind: "message", T: ProductionFilter, repeated: true },
    { no: 4, name: "tag_policies", kind: "message", T: TagPolicy, repeated: true },
    { no: 5, name: "finops_policies", kind: "message", T: FinopsPolicySettings, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RunParameters {
    return new RunParameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RunParameters {
    return new RunParameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RunParameters {
    return new RunParameters().fromJsonString(jsonString, options);
  }

  static equals(a: RunParameters | PlainMessage<RunParameters> | undefined, b: RunParameters | PlainMessage<RunParameters> | undefined): boolean {
    return proto3.util.equals(RunParameters, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.BaseScope
 */
export class BaseScope extends Message<BaseScope> {
  /**
   * @generated from field: string repo_name = 1;
   */
  repoName = "";

  /**
   * @generated from field: string repo_url = 2;
   */
  repoUrl = "";

  /**
   * @generated from field: string branch_name = 3;
   */
  branchName = "";

  constructor(data?: PartialMessage<BaseScope>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.BaseScope";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repo_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "repo_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "branch_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BaseScope {
    return new BaseScope().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BaseScope {
    return new BaseScope().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BaseScope {
    return new BaseScope().fromJsonString(jsonString, options);
  }

  static equals(a: BaseScope | PlainMessage<BaseScope> | undefined, b: BaseScope | PlainMessage<BaseScope> | undefined): boolean {
    return proto3.util.equals(BaseScope, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.UsageDefaults
 */
export class UsageDefaults extends Message<UsageDefaults> {
  /**
   * Key is resource_type
   *
   * @generated from field: map<string, infracost.parser.event.UsageResourceMap> resources = 1;
   */
  resources: { [key: string]: UsageResourceMap } = {};

  constructor(data?: PartialMessage<UsageDefaults>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.UsageDefaults";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resources", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: UsageResourceMap} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UsageDefaults {
    return new UsageDefaults().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UsageDefaults {
    return new UsageDefaults().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UsageDefaults {
    return new UsageDefaults().fromJsonString(jsonString, options);
  }

  static equals(a: UsageDefaults | PlainMessage<UsageDefaults> | undefined, b: UsageDefaults | PlainMessage<UsageDefaults> | undefined): boolean {
    return proto3.util.equals(UsageDefaults, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.UsageResourceMap
 */
export class UsageResourceMap extends Message<UsageResourceMap> {
  /**
   * Key is usage_key
   *
   * @generated from field: map<string, infracost.parser.event.UsageDefaultList> usages = 1;
   */
  usages: { [key: string]: UsageDefaultList } = {};

  constructor(data?: PartialMessage<UsageResourceMap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.UsageResourceMap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "usages", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: UsageDefaultList} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UsageResourceMap {
    return new UsageResourceMap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UsageResourceMap {
    return new UsageResourceMap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UsageResourceMap {
    return new UsageResourceMap().fromJsonString(jsonString, options);
  }

  static equals(a: UsageResourceMap | PlainMessage<UsageResourceMap> | undefined, b: UsageResourceMap | PlainMessage<UsageResourceMap> | undefined): boolean {
    return proto3.util.equals(UsageResourceMap, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.UsageDefaultList
 */
export class UsageDefaultList extends Message<UsageDefaultList> {
  /**
   * @generated from field: repeated infracost.parser.event.UsageDefault list = 1;
   */
  list: UsageDefault[] = [];

  constructor(data?: PartialMessage<UsageDefaultList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.UsageDefaultList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "list", kind: "message", T: UsageDefault, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UsageDefaultList {
    return new UsageDefaultList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UsageDefaultList {
    return new UsageDefaultList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UsageDefaultList {
    return new UsageDefaultList().fromJsonString(jsonString, options);
  }

  static equals(a: UsageDefaultList | PlainMessage<UsageDefaultList> | undefined, b: UsageDefaultList | PlainMessage<UsageDefaultList> | undefined): boolean {
    return proto3.util.equals(UsageDefaultList, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.UsageDefault
 */
export class UsageDefault extends Message<UsageDefault> {
  /**
   * @generated from field: string quantity = 1;
   */
  quantity = "";

  /**
   * @generated from field: int32 priority = 2;
   */
  priority = 0;

  /**
   * @generated from field: infracost.parser.event.UsageFilters filters = 3;
   */
  filters?: UsageFilters;

  constructor(data?: PartialMessage<UsageDefault>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.UsageDefault";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "priority", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "filters", kind: "message", T: UsageFilters },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UsageDefault {
    return new UsageDefault().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UsageDefault {
    return new UsageDefault().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UsageDefault {
    return new UsageDefault().fromJsonString(jsonString, options);
  }

  static equals(a: UsageDefault | PlainMessage<UsageDefault> | undefined, b: UsageDefault | PlainMessage<UsageDefault> | undefined): boolean {
    return proto3.util.equals(UsageDefault, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.UsageFilters
 */
export class UsageFilters extends Message<UsageFilters> {
  /**
   * @generated from field: infracost.parser.event.StringFilter project = 1;
   */
  project?: StringFilter;

  constructor(data?: PartialMessage<UsageFilters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.UsageFilters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project", kind: "message", T: StringFilter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UsageFilters {
    return new UsageFilters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UsageFilters {
    return new UsageFilters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UsageFilters {
    return new UsageFilters().fromJsonString(jsonString, options);
  }

  static equals(a: UsageFilters | PlainMessage<UsageFilters> | undefined, b: UsageFilters | PlainMessage<UsageFilters> | undefined): boolean {
    return proto3.util.equals(UsageFilters, a, b);
  }
}

/**
 * Filter represents a unified-input filter with a type and a value pattern
 * Value may contain '*' wildcards that are translated to a regex.
 * Word boundaries (\\b) are implicitly added at the start and end unless
 * the pattern starts/ends with a wildcard.
 *
 * @generated from message infracost.parser.event.ProductionFilter
 */
export class ProductionFilter extends Message<ProductionFilter> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: infracost.parser.event.ProductionFilter.Type type = 2;
   */
  type = ProductionFilter_Type.UNSPECIFIED;

  /**
   * @generated from field: string value = 3;
   */
  value = "";

  /**
   * @generated from field: bool include = 4;
   */
  include = false;

  constructor(data?: PartialMessage<ProductionFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.ProductionFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(ProductionFilter_Type) },
    { no: 3, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "include", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProductionFilter {
    return new ProductionFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProductionFilter {
    return new ProductionFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProductionFilter {
    return new ProductionFilter().fromJsonString(jsonString, options);
  }

  static equals(a: ProductionFilter | PlainMessage<ProductionFilter> | undefined, b: ProductionFilter | PlainMessage<ProductionFilter> | undefined): boolean {
    return proto3.util.equals(ProductionFilter, a, b);
  }
}

/**
 * Type represents the filter type (e.g., repo/project/branch) and aliases the proto enum.
 *
 * @generated from enum infracost.parser.event.ProductionFilter.Type
 */
export enum ProductionFilter_Type {
  /**
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: REPO = 1;
   */
  REPO = 1,

  /**
   * @generated from enum value: PROJECT = 2;
   */
  PROJECT = 2,

  /**
   * @generated from enum value: BRANCH = 3;
   */
  BRANCH = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ProductionFilter_Type)
proto3.util.setEnumType(ProductionFilter_Type, "infracost.parser.event.ProductionFilter.Type", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "REPO" },
  { no: 2, name: "PROJECT" },
  { no: 3, name: "BRANCH" },
]);

/**
 * @generated from message infracost.parser.event.TagPolicy
 */
export class TagPolicy extends Message<TagPolicy> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: string message = 3;
   */
  message = "";

  /**
   * @generated from field: infracost.parser.event.StringFilter resource_filter = 4;
   */
  resourceFilter?: StringFilter;

  /**
   * @generated from field: infracost.parser.event.StringFilter branch_filter = 5;
   */
  branchFilter?: StringFilter;

  /**
   * @generated from field: infracost.parser.event.StringFilter project_filter = 6;
   */
  projectFilter?: StringFilter;

  /**
   * @generated from field: infracost.parser.event.MapFilter tag_filter = 7;
   */
  tagFilter?: MapFilter;

  /**
   * @generated from field: repeated infracost.parser.event.TagPolicyRequirement requirements = 8;
   */
  requirements: TagPolicyRequirement[] = [];

  /**
   * @generated from field: bool pr_comment = 9;
   */
  prComment = false;

  /**
   * @generated from field: bool block_pr = 10;
   */
  blockPr = false;

  constructor(data?: PartialMessage<TagPolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.TagPolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "resource_filter", kind: "message", T: StringFilter },
    { no: 5, name: "branch_filter", kind: "message", T: StringFilter },
    { no: 6, name: "project_filter", kind: "message", T: StringFilter },
    { no: 7, name: "tag_filter", kind: "message", T: MapFilter },
    { no: 8, name: "requirements", kind: "message", T: TagPolicyRequirement, repeated: true },
    { no: 9, name: "pr_comment", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "block_pr", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TagPolicy {
    return new TagPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TagPolicy {
    return new TagPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TagPolicy {
    return new TagPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: TagPolicy | PlainMessage<TagPolicy> | undefined, b: TagPolicy | PlainMessage<TagPolicy> | undefined): boolean {
    return proto3.util.equals(TagPolicy, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.TagPolicyRequirement
 */
export class TagPolicyRequirement extends Message<TagPolicyRequirement> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: infracost.parser.event.TagPolicyRequirement.Type type = 2;
   */
  type = TagPolicyRequirement_Type.UNSPECIFIED;

  /**
   * @generated from field: string value_regex = 3;
   */
  valueRegex = "";

  /**
   * @generated from field: string message = 4;
   */
  message = "";

  /**
   * @generated from field: repeated string allowed_values = 5;
   */
  allowedValues: string[] = [];

  /**
   * @generated from field: bool mandatory = 6;
   */
  mandatory = false;

  constructor(data?: PartialMessage<TagPolicyRequirement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.TagPolicyRequirement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(TagPolicyRequirement_Type) },
    { no: 3, name: "value_regex", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "allowed_values", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "mandatory", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TagPolicyRequirement {
    return new TagPolicyRequirement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TagPolicyRequirement {
    return new TagPolicyRequirement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TagPolicyRequirement {
    return new TagPolicyRequirement().fromJsonString(jsonString, options);
  }

  static equals(a: TagPolicyRequirement | PlainMessage<TagPolicyRequirement> | undefined, b: TagPolicyRequirement | PlainMessage<TagPolicyRequirement> | undefined): boolean {
    return proto3.util.equals(TagPolicyRequirement, a, b);
  }
}

/**
 * @generated from enum infracost.parser.event.TagPolicyRequirement.Type
 */
export enum TagPolicyRequirement_Type {
  /**
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ANY = 1;
   */
  ANY = 1,

  /**
   * @generated from enum value: LIST = 2;
   */
  LIST = 2,

  /**
   * @generated from enum value: REGEX = 3;
   */
  REGEX = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(TagPolicyRequirement_Type)
proto3.util.setEnumType(TagPolicyRequirement_Type, "infracost.parser.event.TagPolicyRequirement.Type", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "ANY" },
  { no: 2, name: "LIST" },
  { no: 3, name: "REGEX" },
]);

/**
 * @generated from message infracost.parser.event.StringFilter
 */
export class StringFilter extends Message<StringFilter> {
  /**
   * @generated from field: repeated string include = 1;
   */
  include: string[] = [];

  /**
   * @generated from field: repeated string exclude = 2;
   */
  exclude: string[] = [];

  constructor(data?: PartialMessage<StringFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.StringFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "include", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "exclude", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringFilter {
    return new StringFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringFilter {
    return new StringFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringFilter {
    return new StringFilter().fromJsonString(jsonString, options);
  }

  static equals(a: StringFilter | PlainMessage<StringFilter> | undefined, b: StringFilter | PlainMessage<StringFilter> | undefined): boolean {
    return proto3.util.equals(StringFilter, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.MapFilter
 */
export class MapFilter extends Message<MapFilter> {
  /**
   * @generated from field: map<string, string> include = 1;
   */
  include: { [key: string]: string } = {};

  /**
   * @generated from field: map<string, string> exclude = 2;
   */
  exclude: { [key: string]: string } = {};

  constructor(data?: PartialMessage<MapFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.MapFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "include", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 2, name: "exclude", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapFilter {
    return new MapFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapFilter {
    return new MapFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapFilter {
    return new MapFilter().fromJsonString(jsonString, options);
  }

  static equals(a: MapFilter | PlainMessage<MapFilter> | undefined, b: MapFilter | PlainMessage<MapFilter> | undefined): boolean {
    return proto3.util.equals(MapFilter, a, b);
  }
}

/**
 * @generated from message infracost.parser.event.FinopsPolicySettings
 */
export class FinopsPolicySettings extends Message<FinopsPolicySettings> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string slug = 2;
   */
  slug = "";

  /**
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * @generated from field: string message = 4;
   */
  message = "";

  /**
   * @generated from field: infracost.parser.event.StringFilter project_filter = 5;
   */
  projectFilter?: StringFilter;

  /**
   * @generated from field: infracost.parser.event.StringFilter branch_filter = 6;
   */
  branchFilter?: StringFilter;

  /**
   * @generated from field: infracost.parser.event.MapFilter tag_filter = 7;
   */
  tagFilter?: MapFilter;

  /**
   * JSON blob
   *
   * @generated from field: string settings = 8;
   */
  settings = "";

  /**
   * @generated from field: bool pr_comment = 9;
   */
  prComment = false;

  /**
   * @generated from field: bool block_pr = 10;
   */
  blockPr = false;

  /**
   * @generated from field: bool only_new_resources = 11;
   */
  onlyNewResources = false;

  constructor(data?: PartialMessage<FinopsPolicySettings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "infracost.parser.event.FinopsPolicySettings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "slug", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "project_filter", kind: "message", T: StringFilter },
    { no: 6, name: "branch_filter", kind: "message", T: StringFilter },
    { no: 7, name: "tag_filter", kind: "message", T: MapFilter },
    { no: 8, name: "settings", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "pr_comment", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "block_pr", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "only_new_resources", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FinopsPolicySettings {
    return new FinopsPolicySettings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FinopsPolicySettings {
    return new FinopsPolicySettings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FinopsPolicySettings {
    return new FinopsPolicySettings().fromJsonString(jsonString, options);
  }

  static equals(a: FinopsPolicySettings | PlainMessage<FinopsPolicySettings> | undefined, b: FinopsPolicySettings | PlainMessage<FinopsPolicySettings> | undefined): boolean {
    return proto3.util.equals(FinopsPolicySettings, a, b);
  }
}

