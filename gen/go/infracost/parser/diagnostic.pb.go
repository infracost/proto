// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        (unknown)
// source: infracost/parser/diagnostic.proto

package parser

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type DiagnosticType int32

const (
	DiagnosticType_DIAGNOSTIC_TYPE_UNSPECIFIED DiagnosticType = 0
	// failed operation e.g. adding a string to an int, or error in operation func
	DiagnosticType_DIAGNOSTIC_TYPE_FAILED_OPERATION DiagnosticType = 1
	// bug in the parser code
	DiagnosticType_DIAGNOSTIC_TYPE_DEFECT DiagnosticType = 2
	// could not parse the hcl, invalid code
	DiagnosticType_DIAGNOSTIC_TYPE_HCL_PARSE_ERROR DiagnosticType = 3
	// missing function, i.e. not defined
	DiagnosticType_DIAGNOSTIC_TYPE_MISSING_FUNC DiagnosticType = 4
	// failed to call function, cty function errored
	DiagnosticType_DIAGNOSTIC_TYPE_FAILED_FUNCTION_CALL   DiagnosticType = 5
	DiagnosticType_DIAGNOSTIC_TYPE_UNEXPECTED_TYPE        DiagnosticType = 6 // e.g. string used for int
	DiagnosticType_DIAGNOSTIC_TYPE_MODULE_FETCH_ERROR     DiagnosticType = 7 // failed to download module
	DiagnosticType_DIAGNOSTIC_TYPE_MISSING_INPUT_VARIABLE DiagnosticType = 8 // specifically a missing var input
	DiagnosticType_DIAGNOSTIC_TYPE_MISSING_REFERENCE      DiagnosticType = 9
	DiagnosticType_DIAGNOSTIC_TYPE_VALUE_INDEX_ERROR      DiagnosticType = 10 // e.g. cannot index into map
	// unknown expression type - possibly an expression we don't yet support
	DiagnosticType_DIAGNOSTIC_TYPE_UNKNOWN_EXPRESSION DiagnosticType = 11
	// error trying to relatively traverse into a value e.g. function()[3]
	DiagnosticType_DIAGNOSTIC_TYPE_RELATIVE_TRAVERSAL_ERROR DiagnosticType = 12
	// invalid terraform configuration, e.g. dynamic block with no for_each
	DiagnosticType_DIAGNOSTIC_TYPE_INVALID_TERRAFORM_CONFIGURATION DiagnosticType = 13
	// invalid terragrunt configuration, e.g. missing source
	DiagnosticType_DIAGNOSTIC_TYPE_INVALID_TERRAGRUNT_CONFIGURATION DiagnosticType = 14
	// cyclic dependencies detected
	DiagnosticType_DIAGNOSTIC_TYPE_TERRAFORM_CYCLIC_DEPENDENCY_DETECTED DiagnosticType = 15
	// terragrunt cyclic dependency detected
	DiagnosticType_DIAGNOSTIC_TYPE_TERRAGRUNT_CYCLIC_DEPENDENCY_DETECTED DiagnosticType = 16
	// security error, e.g. trying to access a file outside of the repo directory
	DiagnosticType_DIAGNOSTIC_TYPE_SECURITY_ERROR DiagnosticType = 17
	// dependency error, e.g. missing module
	DiagnosticType_DIAGNOSTIC_TYPE_DEPENDENCY_ERROR DiagnosticType = 18
	// filesystem error, e.g. missing file
	DiagnosticType_DIAGNOSTIC_TYPE_FILESYSTEM_ERROR DiagnosticType = 19
	// invalid source map
	DiagnosticType_DIAGNOSTIC_TYPE_INVALID_SOURCE_MAP DiagnosticType = 20
	// no source files found
	DiagnosticType_DIAGNOSTIC_TYPE_NO_SOURCE_FILES_FOUND DiagnosticType = 21
	// yor error
	DiagnosticType_DIAGNOSTIC_TYPE_YOR_ERROR DiagnosticType = 22
	// remote variable load error, e.g. TFC/Spacelift
	DiagnosticType_DIAGNOSTIC_TYPE_REMOTE_VARIABLE_LOAD_ERROR DiagnosticType = 23
	// cloudformation template error
	DiagnosticType_DIAGNOSTIC_TYPE_INVALID_CLOUDFORMATION_TEMPLATE DiagnosticType = 24
	// cloudformation unsupported transform
	DiagnosticType_DIAGNOSTIC_TYPE_UNSUPPORTED_CLOUDFORMATION_TRANSFORM DiagnosticType = 25
	// cloudformation unsupported intrinsic function
	DiagnosticType_DIAGNOSTIC_TYPE_UNSUPPORTED_CLOUDFORMATION_INTRINSIC_FUNCTION DiagnosticType = 26
	// cloudformation synthetic template url
	DiagnosticType_DIAGNOSTIC_TYPE_SYNTHETIC_CLOUDFORMATION_TEMPLATE_URL DiagnosticType = 27
	// cloudformation transform failed
	DiagnosticType_DIAGNOSTIC_TYPE_FAILED_CLOUDFORMATION_TRANSFORM DiagnosticType = 28
)

// Enum value maps for DiagnosticType.
var (
	DiagnosticType_name = map[int32]string{
		0:  "DIAGNOSTIC_TYPE_UNSPECIFIED",
		1:  "DIAGNOSTIC_TYPE_FAILED_OPERATION",
		2:  "DIAGNOSTIC_TYPE_DEFECT",
		3:  "DIAGNOSTIC_TYPE_HCL_PARSE_ERROR",
		4:  "DIAGNOSTIC_TYPE_MISSING_FUNC",
		5:  "DIAGNOSTIC_TYPE_FAILED_FUNCTION_CALL",
		6:  "DIAGNOSTIC_TYPE_UNEXPECTED_TYPE",
		7:  "DIAGNOSTIC_TYPE_MODULE_FETCH_ERROR",
		8:  "DIAGNOSTIC_TYPE_MISSING_INPUT_VARIABLE",
		9:  "DIAGNOSTIC_TYPE_MISSING_REFERENCE",
		10: "DIAGNOSTIC_TYPE_VALUE_INDEX_ERROR",
		11: "DIAGNOSTIC_TYPE_UNKNOWN_EXPRESSION",
		12: "DIAGNOSTIC_TYPE_RELATIVE_TRAVERSAL_ERROR",
		13: "DIAGNOSTIC_TYPE_INVALID_TERRAFORM_CONFIGURATION",
		14: "DIAGNOSTIC_TYPE_INVALID_TERRAGRUNT_CONFIGURATION",
		15: "DIAGNOSTIC_TYPE_TERRAFORM_CYCLIC_DEPENDENCY_DETECTED",
		16: "DIAGNOSTIC_TYPE_TERRAGRUNT_CYCLIC_DEPENDENCY_DETECTED",
		17: "DIAGNOSTIC_TYPE_SECURITY_ERROR",
		18: "DIAGNOSTIC_TYPE_DEPENDENCY_ERROR",
		19: "DIAGNOSTIC_TYPE_FILESYSTEM_ERROR",
		20: "DIAGNOSTIC_TYPE_INVALID_SOURCE_MAP",
		21: "DIAGNOSTIC_TYPE_NO_SOURCE_FILES_FOUND",
		22: "DIAGNOSTIC_TYPE_YOR_ERROR",
		23: "DIAGNOSTIC_TYPE_REMOTE_VARIABLE_LOAD_ERROR",
		24: "DIAGNOSTIC_TYPE_INVALID_CLOUDFORMATION_TEMPLATE",
		25: "DIAGNOSTIC_TYPE_UNSUPPORTED_CLOUDFORMATION_TRANSFORM",
		26: "DIAGNOSTIC_TYPE_UNSUPPORTED_CLOUDFORMATION_INTRINSIC_FUNCTION",
		27: "DIAGNOSTIC_TYPE_SYNTHETIC_CLOUDFORMATION_TEMPLATE_URL",
		28: "DIAGNOSTIC_TYPE_FAILED_CLOUDFORMATION_TRANSFORM",
	}
	DiagnosticType_value = map[string]int32{
		"DIAGNOSTIC_TYPE_UNSPECIFIED":                                   0,
		"DIAGNOSTIC_TYPE_FAILED_OPERATION":                              1,
		"DIAGNOSTIC_TYPE_DEFECT":                                        2,
		"DIAGNOSTIC_TYPE_HCL_PARSE_ERROR":                               3,
		"DIAGNOSTIC_TYPE_MISSING_FUNC":                                  4,
		"DIAGNOSTIC_TYPE_FAILED_FUNCTION_CALL":                          5,
		"DIAGNOSTIC_TYPE_UNEXPECTED_TYPE":                               6,
		"DIAGNOSTIC_TYPE_MODULE_FETCH_ERROR":                            7,
		"DIAGNOSTIC_TYPE_MISSING_INPUT_VARIABLE":                        8,
		"DIAGNOSTIC_TYPE_MISSING_REFERENCE":                             9,
		"DIAGNOSTIC_TYPE_VALUE_INDEX_ERROR":                             10,
		"DIAGNOSTIC_TYPE_UNKNOWN_EXPRESSION":                            11,
		"DIAGNOSTIC_TYPE_RELATIVE_TRAVERSAL_ERROR":                      12,
		"DIAGNOSTIC_TYPE_INVALID_TERRAFORM_CONFIGURATION":               13,
		"DIAGNOSTIC_TYPE_INVALID_TERRAGRUNT_CONFIGURATION":              14,
		"DIAGNOSTIC_TYPE_TERRAFORM_CYCLIC_DEPENDENCY_DETECTED":          15,
		"DIAGNOSTIC_TYPE_TERRAGRUNT_CYCLIC_DEPENDENCY_DETECTED":         16,
		"DIAGNOSTIC_TYPE_SECURITY_ERROR":                                17,
		"DIAGNOSTIC_TYPE_DEPENDENCY_ERROR":                              18,
		"DIAGNOSTIC_TYPE_FILESYSTEM_ERROR":                              19,
		"DIAGNOSTIC_TYPE_INVALID_SOURCE_MAP":                            20,
		"DIAGNOSTIC_TYPE_NO_SOURCE_FILES_FOUND":                         21,
		"DIAGNOSTIC_TYPE_YOR_ERROR":                                     22,
		"DIAGNOSTIC_TYPE_REMOTE_VARIABLE_LOAD_ERROR":                    23,
		"DIAGNOSTIC_TYPE_INVALID_CLOUDFORMATION_TEMPLATE":               24,
		"DIAGNOSTIC_TYPE_UNSUPPORTED_CLOUDFORMATION_TRANSFORM":          25,
		"DIAGNOSTIC_TYPE_UNSUPPORTED_CLOUDFORMATION_INTRINSIC_FUNCTION": 26,
		"DIAGNOSTIC_TYPE_SYNTHETIC_CLOUDFORMATION_TEMPLATE_URL":         27,
		"DIAGNOSTIC_TYPE_FAILED_CLOUDFORMATION_TRANSFORM":               28,
	}
)

func (x DiagnosticType) Enum() *DiagnosticType {
	p := new(DiagnosticType)
	*p = x
	return p
}

func (x DiagnosticType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DiagnosticType) Descriptor() protoreflect.EnumDescriptor {
	return file_infracost_parser_diagnostic_proto_enumTypes[0].Descriptor()
}

func (DiagnosticType) Type() protoreflect.EnumType {
	return &file_infracost_parser_diagnostic_proto_enumTypes[0]
}

func (x DiagnosticType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DiagnosticType.Descriptor instead.
func (DiagnosticType) EnumDescriptor() ([]byte, []int) {
	return file_infracost_parser_diagnostic_proto_rawDescGZIP(), []int{0}
}

// Diagnostic is information about something that went wrong during
// parsing, for any reason.
// A Diagnostic is considered Critical if it is something the user needs
// to be alerted about, e.g. a module download failing due to invalid
// credentials.
type Diagnostic struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Error         string                 `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	Labels        map[string]string      `protobuf:"bytes,2,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	SourceRange   *SourceRange           `protobuf:"bytes,3,opt,name=source_range,json=sourceRange,proto3" json:"source_range,omitempty"`
	Type          DiagnosticType         `protobuf:"varint,4,opt,name=type,proto3,enum=infracost.parser.DiagnosticType" json:"type,omitempty"`
	Critical      bool                   `protobuf:"varint,5,opt,name=critical,proto3" json:"critical,omitempty"`
	Warning       bool                   `protobuf:"varint,6,opt,name=warning,proto3" json:"warning,omitempty"`
	Ignored       bool                   `protobuf:"varint,7,opt,name=ignored,proto3" json:"ignored,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Diagnostic) Reset() {
	*x = Diagnostic{}
	mi := &file_infracost_parser_diagnostic_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Diagnostic) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Diagnostic) ProtoMessage() {}

func (x *Diagnostic) ProtoReflect() protoreflect.Message {
	mi := &file_infracost_parser_diagnostic_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Diagnostic.ProtoReflect.Descriptor instead.
func (*Diagnostic) Descriptor() ([]byte, []int) {
	return file_infracost_parser_diagnostic_proto_rawDescGZIP(), []int{0}
}

func (x *Diagnostic) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *Diagnostic) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Diagnostic) GetSourceRange() *SourceRange {
	if x != nil {
		return x.SourceRange
	}
	return nil
}

func (x *Diagnostic) GetType() DiagnosticType {
	if x != nil {
		return x.Type
	}
	return DiagnosticType_DIAGNOSTIC_TYPE_UNSPECIFIED
}

func (x *Diagnostic) GetCritical() bool {
	if x != nil {
		return x.Critical
	}
	return false
}

func (x *Diagnostic) GetWarning() bool {
	if x != nil {
		return x.Warning
	}
	return false
}

func (x *Diagnostic) GetIgnored() bool {
	if x != nil {
		return x.Ignored
	}
	return false
}

var File_infracost_parser_diagnostic_proto protoreflect.FileDescriptor

const file_infracost_parser_diagnostic_proto_rawDesc = "" +
	"\n" +
	"!infracost/parser/diagnostic.proto\x12\x10infracost.parser\x1a\x1finfracost/parser/metadata.proto\"\xe7\x02\n" +
	"\n" +
	"Diagnostic\x12\x14\n" +
	"\x05error\x18\x01 \x01(\tR\x05error\x12@\n" +
	"\x06labels\x18\x02 \x03(\v2(.infracost.parser.Diagnostic.LabelsEntryR\x06labels\x12@\n" +
	"\fsource_range\x18\x03 \x01(\v2\x1d.infracost.parser.SourceRangeR\vsourceRange\x124\n" +
	"\x04type\x18\x04 \x01(\x0e2 .infracost.parser.DiagnosticTypeR\x04type\x12\x1a\n" +
	"\bcritical\x18\x05 \x01(\bR\bcritical\x12\x18\n" +
	"\awarning\x18\x06 \x01(\bR\awarning\x12\x18\n" +
	"\aignored\x18\a \x01(\bR\aignored\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01*\x95\n" +
	"\n" +
	"\x0eDiagnosticType\x12\x1f\n" +
	"\x1bDIAGNOSTIC_TYPE_UNSPECIFIED\x10\x00\x12$\n" +
	" DIAGNOSTIC_TYPE_FAILED_OPERATION\x10\x01\x12\x1a\n" +
	"\x16DIAGNOSTIC_TYPE_DEFECT\x10\x02\x12#\n" +
	"\x1fDIAGNOSTIC_TYPE_HCL_PARSE_ERROR\x10\x03\x12 \n" +
	"\x1cDIAGNOSTIC_TYPE_MISSING_FUNC\x10\x04\x12(\n" +
	"$DIAGNOSTIC_TYPE_FAILED_FUNCTION_CALL\x10\x05\x12#\n" +
	"\x1fDIAGNOSTIC_TYPE_UNEXPECTED_TYPE\x10\x06\x12&\n" +
	"\"DIAGNOSTIC_TYPE_MODULE_FETCH_ERROR\x10\a\x12*\n" +
	"&DIAGNOSTIC_TYPE_MISSING_INPUT_VARIABLE\x10\b\x12%\n" +
	"!DIAGNOSTIC_TYPE_MISSING_REFERENCE\x10\t\x12%\n" +
	"!DIAGNOSTIC_TYPE_VALUE_INDEX_ERROR\x10\n" +
	"\x12&\n" +
	"\"DIAGNOSTIC_TYPE_UNKNOWN_EXPRESSION\x10\v\x12,\n" +
	"(DIAGNOSTIC_TYPE_RELATIVE_TRAVERSAL_ERROR\x10\f\x123\n" +
	"/DIAGNOSTIC_TYPE_INVALID_TERRAFORM_CONFIGURATION\x10\r\x124\n" +
	"0DIAGNOSTIC_TYPE_INVALID_TERRAGRUNT_CONFIGURATION\x10\x0e\x128\n" +
	"4DIAGNOSTIC_TYPE_TERRAFORM_CYCLIC_DEPENDENCY_DETECTED\x10\x0f\x129\n" +
	"5DIAGNOSTIC_TYPE_TERRAGRUNT_CYCLIC_DEPENDENCY_DETECTED\x10\x10\x12\"\n" +
	"\x1eDIAGNOSTIC_TYPE_SECURITY_ERROR\x10\x11\x12$\n" +
	" DIAGNOSTIC_TYPE_DEPENDENCY_ERROR\x10\x12\x12$\n" +
	" DIAGNOSTIC_TYPE_FILESYSTEM_ERROR\x10\x13\x12&\n" +
	"\"DIAGNOSTIC_TYPE_INVALID_SOURCE_MAP\x10\x14\x12)\n" +
	"%DIAGNOSTIC_TYPE_NO_SOURCE_FILES_FOUND\x10\x15\x12\x1d\n" +
	"\x19DIAGNOSTIC_TYPE_YOR_ERROR\x10\x16\x12.\n" +
	"*DIAGNOSTIC_TYPE_REMOTE_VARIABLE_LOAD_ERROR\x10\x17\x123\n" +
	"/DIAGNOSTIC_TYPE_INVALID_CLOUDFORMATION_TEMPLATE\x10\x18\x128\n" +
	"4DIAGNOSTIC_TYPE_UNSUPPORTED_CLOUDFORMATION_TRANSFORM\x10\x19\x12A\n" +
	"=DIAGNOSTIC_TYPE_UNSUPPORTED_CLOUDFORMATION_INTRINSIC_FUNCTION\x10\x1a\x129\n" +
	"5DIAGNOSTIC_TYPE_SYNTHETIC_CLOUDFORMATION_TEMPLATE_URL\x10\x1b\x123\n" +
	"/DIAGNOSTIC_TYPE_FAILED_CLOUDFORMATION_TRANSFORM\x10\x1cB\xbc\x01\n" +
	"\x14com.infracost.parserB\x0fDiagnosticProtoP\x01Z2github.com/infracost/proto/gen/go/infracost/parser\xa2\x02\x03IPX\xaa\x02\x10Infracost.Parser\xca\x02\x10Infracost\\Parser\xe2\x02\x1cInfracost\\Parser\\GPBMetadata\xea\x02\x11Infracost::Parserb\x06proto3"

var (
	file_infracost_parser_diagnostic_proto_rawDescOnce sync.Once
	file_infracost_parser_diagnostic_proto_rawDescData []byte
)

func file_infracost_parser_diagnostic_proto_rawDescGZIP() []byte {
	file_infracost_parser_diagnostic_proto_rawDescOnce.Do(func() {
		file_infracost_parser_diagnostic_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_infracost_parser_diagnostic_proto_rawDesc), len(file_infracost_parser_diagnostic_proto_rawDesc)))
	})
	return file_infracost_parser_diagnostic_proto_rawDescData
}

var file_infracost_parser_diagnostic_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_infracost_parser_diagnostic_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_infracost_parser_diagnostic_proto_goTypes = []any{
	(DiagnosticType)(0), // 0: infracost.parser.DiagnosticType
	(*Diagnostic)(nil),  // 1: infracost.parser.Diagnostic
	nil,                 // 2: infracost.parser.Diagnostic.LabelsEntry
	(*SourceRange)(nil), // 3: infracost.parser.SourceRange
}
var file_infracost_parser_diagnostic_proto_depIdxs = []int32{
	2, // 0: infracost.parser.Diagnostic.labels:type_name -> infracost.parser.Diagnostic.LabelsEntry
	3, // 1: infracost.parser.Diagnostic.source_range:type_name -> infracost.parser.SourceRange
	0, // 2: infracost.parser.Diagnostic.type:type_name -> infracost.parser.DiagnosticType
	3, // [3:3] is the sub-list for method output_type
	3, // [3:3] is the sub-list for method input_type
	3, // [3:3] is the sub-list for extension type_name
	3, // [3:3] is the sub-list for extension extendee
	0, // [0:3] is the sub-list for field type_name
}

func init() { file_infracost_parser_diagnostic_proto_init() }
func file_infracost_parser_diagnostic_proto_init() {
	if File_infracost_parser_diagnostic_proto != nil {
		return
	}
	file_infracost_parser_metadata_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_infracost_parser_diagnostic_proto_rawDesc), len(file_infracost_parser_diagnostic_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_infracost_parser_diagnostic_proto_goTypes,
		DependencyIndexes: file_infracost_parser_diagnostic_proto_depIdxs,
		EnumInfos:         file_infracost_parser_diagnostic_proto_enumTypes,
		MessageInfos:      file_infracost_parser_diagnostic_proto_msgTypes,
	}.Build()
	File_infracost_parser_diagnostic_proto = out.File
	file_infracost_parser_diagnostic_proto_goTypes = nil
	file_infracost_parser_diagnostic_proto_depIdxs = nil
}
